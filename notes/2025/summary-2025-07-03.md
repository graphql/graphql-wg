# Meeting Summary for Working Group Meeting

**NOTICE**: This summary was auto-generated by Zoom's "AI". AI-generated
content may be inaccurate or misleading. Always check for accuracy. If in
doubt, please consult the meeting recording at
https://youtube.com/@GraphQLFoundation/playlists

- Meeting start: 2025-07-03T17:29:36Z
- Meeting end: 2025-07-03T19:04:05Z
- Summary start: 2025-07-03T17:31:15Z
- Summary end: 2025-07-03T19:03:55Z

The GraphQL Working Group meeting focused on reviewing recent specification updates and editorial changes, including discussions about request errors, operation execution, and meta fields implementation. The team evaluated various RFC proposals related to coercion algorithms, schema coordinates, and the handling of meta fields in GraphQL.js, with several members providing feedback on potential improvements and clarifications. The conversation ended with discussions about the implementation of experimental features like executeIncrementally and the handling of asynchronous iterators, with the team agreeing to maintain a general specification while allowing for implementation-specific details in GraphQL.js.

## Next Steps

- Lee: Complete final editorial review of the spec before the next cut
- Lee: Review and finalize editorial changes for schema coordinates Meta field handling in the spec
- Benjie: Create a more detailed proposal for execute Meta field algorithm with specific handling for __type, __schema, and __type Meta fields
- Rob: Create a PR to update GraphQL.js regarding schema coordinate Meta field behavior
- Rob: Continue work on the incremental delivery integration branch and merge approved sections
- Lee: Review and polish pending changes for the next spec cut in the coming days
- Benjie: Review Rob's pull request for section 3 spec edits regarding directive definitions

## Summary

### GraphQL Working Group Meeting Updates

The GraphQL Working Group meeting began with Lee noting the thinner attendance due to the holiday week and introduced the agenda, which included updates on the spec, editorial changes, and several RFCs. Benjie highlighted the upcoming discount period for GraphQL Conference tickets and provided a summary of the previous meeting's progress, including merged items like executable descriptions and deprecation discussions. The group planned to discuss schema coordinates, argument values, list coercion algorithms, and incorporating Meta fields into execute collected fields, among other topics. Lee encouraged attendees to review the previous meeting's outcomes and emphasized the importance of highlighting upcoming dates to avoid scheduling conflicts.

### Refining Error Classification in Specifications

Benjie proposed changes to clarify the distinction between request errors and operation execution errors in the specification, focusing on terminology adjustments and editorial updates. Leebyron encouraged others to review the changes and expressed concerns about the placement of subscription-specific logic within the request execution phase, suggesting a need for further consideration of subscriptions' unique steps. Benjie acknowledged the complexity of subscriptions and considered creating a new algorithm but decided to maintain the current approach for now, aiming for a clean separation between request and operation execution phases.

### Schema Meta Fields Implementation Discussion

The team discussed schema coordinates and meta fields, with Mark and Benjie presenting a solution that defines implementation-specific behavior for unresolved meta fields. Leebyron expressed satisfaction with the current proposal, though he may refine the language to clarify the meta case further. The group agreed that the current specification is acceptable, with Martin suggesting the possibility of introducing resolving logic in future releases. The team also noted that the GraphQL.js implementation needs updating to reflect the new changes.

### GraphQL Meta Fields Implementation Discussion

The team discussed the specification of meta fields and their implementation in GraphQL.js. They agreed that meta field resolution should be left implementation-specific, with GraphQL.js currently returning virtual objects. Mark will update the JavaScript version to ensure it aligns with this approach. The team decided not to rush the specification cutoff date of July 1st, as most major changes have been merged and they are close to RFC 3. Leebyron will conduct a final editorial review, and Mark will submit a pull request to address the remaining issues.

### GraphQL Schema and Coercion Discussion

The meeting focused on discussing schema coordinates and meta fields, with Leebyron explaining that meta fields are not part of the schema and can be implementation-specific. Benjie highlighted the distinction between schema elements and introspection types, noting that introspection queries may include both schema and implementation-specific types. The group also discussed two RFCs related to argument value coercion in GraphQL, with Leebyron proposing a more significant rewrite of the algorithm to avoid relying on the "hasValue" concept. Benjie presented a coercion table for arrays and input objects, which aligns with GraphQL.js behavior and addresses underspecified areas in the current specification.

### GraphQL Input Coercion Discussion

Benjie and Lee discussed advancing a GraphQL specification for input coercion, particularly focusing on list coercion. Lee suggested not advancing to Stage 2 due to incomplete definitions for input object coercion, proposing instead to address the entire input coercion domain holistically. Benjie argued for prioritizing a more specific solution for list coercion to help implementations, with the possibility of a later refactor to address the broader input coercion problem. They agreed to proceed with the current draft for list coercion while exploring a more comprehensive solution in parallel.

### Value Coercion Specification Discussion

Leebyron and Benjie discussed the approach to handling value coercion in the specification, comparing it to the existing value completion algorithm. They agreed that a more algorithmic approach would be clearer than prose-based descriptions. Leebyron supported merging a fix for the "has value" bug into the current specification release, as it addressed an active issue rather than just clarifying ambiguity. They decided to mark this change as an RFC rather than an editorial update, acknowledging that it would change behavior in implementations.

### GraphQL Specification Updates Discussion

Leebyron and Benjie discussed recent changes to the GraphQL specification, focusing on clarifying the collection and execution phases. They highlighted a significant renaming and cleanup of variables, which Benjie had worked on, and encouraged others to review this change, especially those working on implementations like GraphQL.js or GraphQL Kotlin. Benjie also explained that he had added support for executing Meta fields in the specification, aligning it with the behavior in GraphQL.js, and avoided using undefined or null values to maintain consistency. Leebyron approved of these changes and suggested that the next steps involve further work on top of this updated foundation.

### GraphQL Meta Fields Implementation Discussion

The team discussed the placement and implementation of meta fields in the GraphQL specification. Leebyron and Benjie agreed that the current location in the spec is appropriate, as it correctly implements the behavior for meta fields. They decided that this change should move through the RFC phases quickly since it addresses a clear hole in the specification. The team also discussed the implications of meta fields returning complex types instead of simple strings, but ultimately decided to keep the implementation implicit rather than making it more explicit, as they felt it would unnecessarily complicate the spec. Leebyron concluded that this change should at least be RFC 1, as it clearly solves a problem in the specification.

### GraphQL Meta Fields Discussion

Lee and Benjie discuss two potential approaches for defining meta fields in the GraphQL specification. They agree to leave the current proposal as RFC1 and consider a more detailed alternative that defines the three meta fields and their behavior. Lee suggests that once they decide on the appropriate draft, it can likely move directly to RFC3 without needing GraphQL.js changes. Benjie notes that the implementation needs to be in the "execute collected fields" section. They also discuss where to place the new algorithm in the spec, with Lee preferring to keep it in the execution section.

### GraphQL.js Incremental Execution Return Type

The team discussed the return type of the experimental `executeIncrementally` function in GraphQL.js, focusing on whether to use a wrapper object or an async generator for incremental delivery results. Leebyron suggested keeping the spec general and implementation-specific, as the async generator and stream concepts are equivalent from an HTTP API consumer's perspective. Rob agreed to keep the spec description general, leaving the exact GraphQL.js implementation details to the mutators. Leebyron highlighted the benefits of the current type system, which unifies the path for operations with and without defers and streams, and suggested that the return type could evolve in the future to better align with these goals.

### GraphQL Server Implementation Discussion

The team discussed the implementation of GraphQL servers and the handling of asynchronous iterators, with Benjie expressing concerns about potential pitfalls for developers who might incorrectly handle map objects containing streams. Leebyron and Benjie agreed that while GraphQL.js should use a more specific type system to handle initial and subsequent results, the specification should describe it as a stream to maintain consistency across transports. Rob mentioned a pull request for editorial changes to section 3 of the spec, which Benjie agreed to review, and Leebyron encouraged merging changes into the integration branch at an early stage to facilitate the review process.
